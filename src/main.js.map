{"mappings":"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","sources":["src/main.js"],"names":["storageApi","forEach","m","_ref","$d4bfe31f3c0d46c344a227222269e$var$_asyncToGenerator","regeneratorRuntime","mark","_callee","k","v","wrap","_context","prev","next","abrupt","localStorage","stop","_x","_x2","apply","this","arguments","Auth","_this","_ref2","length","undefined","_ref2$name","name","apiKey","redirectUri","_ref2$storage","storage","$d4bfe31f3c0d46c344a227222269e$var$_classCallCheck","Error","Object","assign","listeners","get","sKey","then","user","JSON","parse","refreshIdToken","fetchProfile","emit","window","addEventListener","e","key","setState","newValue","_this2","cb","_this3","push","filter","fn","concat","endpoint","body","url","fetch","method","stringify","_ref3","_callee2","response","data","_context2","json","sent","ok","error","message","replace","defineProperty","value","Date","headers","_x3","userData","persist","now","tokenManager","expiresAt","api","grant_type","refresh_token","refreshToken","idToken","id_token","_this4","$d4bfe31f3c0d46c344a227222269e$var$_objectSpread","resource","init","request","Request","set","token","returnSecureToken","options","provider","oauthScope","context","linkAccount","enforceAuth","continueUri","authFlowType","providerId","authUri","sessionId","location","requestUri","href","remove","history","replaceState","origin","pathname","match","finishProviderSignIn","oobCode","email","password","requestType","verifyEmail","continueUrl","newPassword","identifier","kind","users","newData","updatedData","signOut"],"version":3,"file":"main.js.map","sourcesContent":["/**\n * Full documentation for the \"identitytoolkit\" API can be found here:\n * https://cloud.google.com/identity-platform/docs/reference/rest/v1/accounts\n */\n\n/**\n * Settings object for an IDP(Identity Provider).\n * @typedef {Object} ProviderOptions\n * @property {string} options.name The name of the provider in lowercase.\n * @property {string} [options.scope] The scopes for the IDP, this is optional and defaults to \"openid email\".\n */\n\n/**\n * Object response from a \"fetchProvidersForEmail\" request.\n * @typedef {Object} ProvidersForEmailResponse\n * @property {Array.<string>} allProviders All providers the user has once used to do federated login\n * @property {boolean} registered All sign-in methods this user has used.\n * @property {string} sessionId Session ID which should be passed in the following verifyAssertion request\n * @property {Array.<string>} signinMethods All sign-in methods this user has used.\n */\n\n/**\n * Setting object for the \"startOauthFlow\" method.\n * @typedef {Object} oauthFlowOptions\n * @property {string} provider Name of the provider to use.\n * @property {string} [context] A string that will be returned after the Oauth flow is finished, should be used to retain context.\n * @property {boolean} [linkAccount = false] Whether to link this oauth account with the current account. defaults to false.\n */\n\n// Generate a local storage adapter.\n// Its a bit verbose, but takes less characters than writing it manually.\nconst storageApi = {};\n['set', 'get', 'remove'].forEach(m => (storageApi[m] = async (k, v) => localStorage[m + 'Item'](k, v)));\n\n/**\n * Encapsulates authentication flow logic.\n * @param {Object} options Options object.\n * @param {string} options.apiKey The firebase API key\n * @param {string} options.redirectUri The redirect URL used by OAuth providers.\n * @param {Array.<ProviderOptions|string>} options.providers Array of arguments that will be passed to the addProvider method.\n */\nexport default class Auth {\n\tconstructor({ name = 'default', apiKey, redirectUri, storage = storageApi } = {}) {\n\t\tif (typeof apiKey !== 'string') throw Error('The argument \"apiKey\" is required');\n\n\t\tObject.assign(this, {\n\t\t\tname,\n\t\t\tapiKey,\n\t\t\tstorage,\n\t\t\tredirectUri,\n\t\t\tlisteners: []\n\t\t});\n\n\t\tthis.storage.get(this.sKey('User')).then(user => {\n\t\t\tthis.user = JSON.parse(user);\n\t\t\tif (user) this.refreshIdToken().then(() => this.fetchProfile());\n\t\t\telse this.emit();\n\t\t});\n\n\t\t// Because this library is used in react native, outside the browser as well,\n\t\t// we need to first check if this environment supports `addEventListener` on the window.\n\t\t'addEventListener' in window &&\n\t\t\twindow.addEventListener('storage', e => {\n\t\t\t\t// This code will run if localStorage for this user\n\t\t\t\t// data was updated from a different browser window.\n\t\t\t\tif (e.key !== this.sKey('User')) return;\n\t\t\t\tthis.setState(JSON.parse(e.newValue), false);\n\t\t\t});\n\t}\n\n\t/**\n\t * Emits an event and triggers all of the listeners.\n\t * @param {string} name The name of the event to trigger.\n\t * @param {any} data The data you want to pass to the event listeners.\n\t * @private\n\t */\n\temit() {\n\t\tthis.listeners.forEach(cb => cb(this.user));\n\t}\n\n\t/**\n\t * Set up a function that will be called whenever the user state is changed.\n\t * @param {function} cb The function to call when the event is triggered.\n\t * @returns {function} function that will unsubscribe your callback from being called.\n\t */\n\tlisten(cb) {\n\t\tthis.listeners.push(cb);\n\n\t\t// Return a function to unbind the callback.\n\t\treturn () => (this.listeners = this.listeners.filter(fn => fn !== cb));\n\t}\n\n\t/**\n\t * Generates a unique storage key for this app.\n\t * @private\n\t */\n\tsKey(key) {\n\t\treturn `Auth:${key}:${this.apiKey}:${this.name}`;\n\t}\n\n\t/**\n\t * Make post request to a specific endpoint, and return the response.\n\t * @param {string} endpoint The name of the endpoint.\n\t * @param {any} request Body to pass to the request.\n\t * @private\n\t */\n\tapi(endpoint, body) {\n\t\tconst url =\n\t\t\tendpoint === 'token'\n\t\t\t\t? `https://securetoken.googleapis.com/v1/token?key=${this.apiKey}`\n\t\t\t\t: `https://identitytoolkit.googleapis.com/v1/accounts:${endpoint}?key=${this.apiKey}`;\n\n\t\treturn fetch(url, {\n\t\t\tmethod: 'POST',\n\t\t\tbody: typeof body === 'string' ? body : JSON.stringify(body)\n\t\t}).then(async response => {\n\t\t\tlet data = await response.json();\n\n\t\t\t// If the response returned an error, try to get a Firebase error code/message.\n\t\t\t// Sometimes the error codes are joined with an explanation, we don't need that(its a bug).\n\t\t\t// So we remove the unnecessary part.\n\t\t\tif (!response.ok) {\n\t\t\t\tthrow Error(data.error.message.replace(/: [\\w ,.'\"()]+$/, ''));\n\t\t\t}\n\n\t\t\t// Add a hidden date property to the returned object.\n\t\t\t// Used mostly to calculate the expiration date for tokens.\n\t\t\tObject.defineProperty(data, 'expiresAt', { value: Date.parse(response.headers.get('date')) + 3600 * 1000 });\n\t\t\treturn data;\n\t\t});\n\t}\n\n\t/**\n\t * Makes sure the user is logged in and has up-to-date credentials.\n\t * @throws Will throw if the user is not logged in.\n\t * @private\n\t */\n\tasync enforceAuth() {\n\t\tif (!this.user) throw Error('The user must be logged-in to use this method.');\n\t\treturn this.refreshIdToken(); // Won't do anything if the token is valid.\n\t}\n\n\t/**\n\t * Updates the user data in the localStorage.\n\t * @param {Object} userData the new user data.\n\t * @param {boolean} [updateStorage = true] Whether to update local storage or not.\n\t * @private\n\t */\n\tasync setState(userData, persist = true, emit = true) {\n\t\tthis.user = userData;\n\t\tpersist && (await this.storage[userData ? 'set' : 'remove'](this.sKey('User'), JSON.stringify(userData)));\n\t\temit && this.emit();\n\t}\n\n\t/**\n\t * Sign out the currently signed in user.\n\t * Removes all data stored in the storage that's associated with the user.\n\t */\n\tsignOut() {\n\t\treturn this.setState(null);\n\t}\n\n\t/**\n\t * Refreshes the idToken by using the locally stored refresh token\n\t * only if the idToken has expired.\n\t * @private\n\t */\n\tasync refreshIdToken() {\n\t\t// If the idToken didn't expire, return.\n\t\tif (Date.now() < this.user.tokenManager.expiresAt) return;\n\n\t\t// If a request for a new token was already made, then wait for it and then return.\n\t\tif (this._ref) {\n\t\t\treturn void (await this._ref);\n\t\t}\n\n\t\ttry {\n\t\t\t// Save the promise so that if this function is called\n\t\t\t// anywhere else we don't make more than one request.\n\t\t\tthis._ref = this.api('token', {\n\t\t\t\tgrant_type: 'refresh_token',\n\t\t\t\trefresh_token: this.user.tokenManager.refreshToken\n\t\t\t}).then(data => {\n\t\t\t\tconst tokenManager = {\n\t\t\t\t\tidToken: data.id_token,\n\t\t\t\t\trefreshToken: data.refresh_token,\n\t\t\t\t\texpiresAt: data.expiresAt\n\t\t\t\t};\n\t\t\t\treturn this.setState({ ...this.user, tokenManager }, true, false);\n\t\t\t});\n\t\t\tawait this._ref;\n\t\t} finally {\n\t\t\tthis._ref = null;\n\t\t}\n\t}\n\n\t/**\n\t * Uses native fetch, but adds authorization headers otherwise the API is exactly the same as native fetch.\n\t * @param {Request|Object|string} resource the resource to send the request to, or an options object.\n\t * @param {Object} init an options object.\n\t */\n\tasync authorizedRequest(resource, init) {\n\t\tconst request = resource instanceof Request ? resource : new Request(resource, init);\n\n\t\tif (this.user) {\n\t\t\tawait this.refreshIdToken(); // Won't do anything if the token didn't expire yet.\n\t\t\trequest.headers.set('Authorization', `Bearer ${this.user.tokenManager.idToken}`);\n\t\t}\n\n\t\treturn fetch(request);\n\t}\n\n\t/**\n\t * Signs in or signs up a user by exchanging a custom Auth token.\n\t * @param {string} token The custom token.\n\t */\n\tasync signInWithCustomToken(token) {\n\t\t// Try to exchange the Auth Code for an idToken and refreshToken.\n\t\t// And then get the user profile.\n\t\treturn await this.fetchProfile(\n\t\t\tawait this.api('signInWithCustomToken', {\n\t\t\t\ttoken,\n\t\t\t\treturnSecureToken: true\n\t\t\t})\n\t\t);\n\t}\n\n\t/**\n\t * Start auth flow of a federated Id provider.\n\t * Will redirect the page to the federated login page.\n\t * @param {oauthFlowOptions|string} options An options object, or a string with the name of the provider.\n\t */\n\tasync signInWithProvider(options) {\n\t\tif (!this.redirectUri)\n\t\t\tthrow Error('In order to use an Identity provider you should initiate the \"Auth\" instance with a \"redirectUri\".');\n\n\t\t// The options can be a string, or an object, so here we make sure we extract the right data in each case.\n\t\tconst { provider, oauthScope, context, linkAccount } =\n\t\t\ttypeof options === 'string' ? { provider: options } : options;\n\n\t\t// Make sure the user is logged in when an \"account link\" was requested.\n\t\tif (linkAccount) await this.enforceAuth();\n\n\t\t// Get the url and other data necessary for the authentication.\n\t\tconst { authUri, sessionId } = await this.api('createAuthUri', {\n\t\t\tcontinueUri: this.redirectUri,\n\t\t\tauthFlowType: 'CODE_FLOW',\n\t\t\tproviderId: provider,\n\t\t\toauthScope,\n\t\t\tcontext\n\t\t});\n\n\t\t// Save the sessionId that we just received in the local storage.\n\t\t// Is required to finish the auth flow, I believe this is used to mitigate CSRF attacks.\n\t\t// (No docs on this...)\n\t\tawait this.storage.set(this.sKey('SessionId'), sessionId);\n\t\t// Save if this is a fresh log-in or a \"link account\" request.\n\t\tlinkAccount && (await this.storage.set(this.sKey('LinkAccount'), true));\n\n\t\t// Finally - redirect the page to the auth endpoint.\n\t\tlocation.assign(authUri);\n\t}\n\n\t/**\n\t * Signs in or signs up a user using credentials from an Identity Provider (IdP) after a redirect.\n\t * Will fail silently if the URL doesn't have a \"code\" search param.\n\t * @param {string} [requestUri] The request URI with the authorization code, state etc. from the IdP.\n\t * @private\n\t */\n\tasync finishProviderSignIn(requestUri = location.href) {\n\t\t// Get the sessionId we received before the redirect from storage.\n\t\tconst sessionId = await this.storage.get(this.sKey('SessionId'));\n\t\t// Get the indication if this was a \"link account\" request.\n\t\tconst linkAccount = await this.storage.get(this.sKey('LinkAccount'));\n\t\t// Check for the edge case in which the user signed out before completing the linkAccount\n\t\t// Request.\n\t\tif (linkAccount && !this.user) throw Error('Request to \"Link account\" was made, but user is no longer signed-in');\n\t\tawait this.storage.remove(this.sKey('LinkAccount'));\n\n\t\t// Try to exchange the Auth Code for an idToken and refreshToken.\n\t\tconst { idToken, refreshToken, expiresAt, context } = await this.api('signInWithIdp', {\n\t\t\t// If this is a \"link account\" flow, then attach the idToken of the currently logged in account.\n\t\t\tidToken: linkAccount ? this.user.tokenManager.idToken : undefined,\n\t\t\trequestUri,\n\t\t\tsessionId,\n\t\t\treturnSecureToken: true\n\t\t});\n\n\t\t// Now get the user profile.\n\t\tawait this.fetchProfile({ idToken, refreshToken, expiresAt });\n\n\t\t// Remove sensitive data from the URLSearch params in the location bar.\n\t\thistory.replaceState(null, null, location.origin + location.pathname);\n\n\t\treturn context;\n\t}\n\n\t/**\n\t * Handles all sign in flows that complete via redirects.\n\t * Fails silently if no redirect was detected.\n\t */\n\tasync handleSignInRedirect() {\n\t\t// Oauth Federated Identity Provider flow.\n\t\tif (location.href.match(/[&?]code=/)) return this.finishProviderSignIn();\n\n\t\t// Email Sign-in flow.\n\t\tif (location.href.match(/[&?]oobCode=/)) {\n\t\t\tconst oobCode = location.href.match(/[?&]oobCode=([^&]+)/)[1];\n\t\t\tconst email = location.href.match(/[?&]email=([^&]+)/)[1];\n\t\t\tconst expiresAt = Date.now() + 3600 * 1000;\n\t\t\tconst { idToken, refreshToken } = await this.api('signInWithEmailLink', { oobCode, email });\n\t\t\t// Now get the user profile.\n\t\t\tawait this.fetchProfile({ idToken, refreshToken, expiresAt });\n\t\t\t// Remove sensitive data from the URLSearch params in the location bar.\n\t\t\thistory.replaceState(null, null, location.origin + location.pathname);\n\t\t}\n\t}\n\n\t/**\n\t * Signs up with email and password or anonymously when no arguments are passed.\n\t * Automatically signs the user in on completion.\n\t * @param {string} [email] The email for the user to create.\n\t * @param {string} [password] The password for the user to create.\n\t */\n\tasync signUp(email, password) {\n\t\t// Sign up and then retrieve the user profile and persists the session.\n\t\treturn await this.fetchProfile(\n\t\t\tawait this.api('signUp', {\n\t\t\t\temail,\n\t\t\t\tpassword,\n\t\t\t\treturnSecureToken: true\n\t\t\t})\n\t\t);\n\t}\n\n\t/**\n\t * Signs in a user with email and password.\n\t * @param {string} email\n\t * @param {string} password\n\t */\n\tasync signIn(email, password) {\n\t\t// Sign up and then retrieve the user profile and persists the session.\n\t\treturn await this.fetchProfile(\n\t\t\tawait this.api('signInWithPassword', {\n\t\t\t\temail,\n\t\t\t\tpassword,\n\t\t\t\treturnSecureToken: true\n\t\t\t})\n\t\t);\n\t}\n\n\t/**\n\t * Sends an out-of-band confirmation code for an account.\n\t * Can be used to reset a password, to verify an email address and send a Sign-in email link.\n\t * The `email` argument is not needed only when verifying an email(In that case it will be completely ignored, even if specified), otherwise it is required.\n\t * @param {'PASSWORD_RESET'|'VERIFY_EMAIL'|'EMAIL_SIGNIN'} requestType The type of out-of-band (OOB) code to send.\n\t * @param {string} [email] When the `requestType` is `PASSWORD_RESET` or `EMAIL_SIGNIN` you need to provide an email address.\n\t * @returns {Promise}\n\t */\n\tasync sendOobCode(requestType, email) {\n\t\tconst verifyEmail = requestType === 'VERIFY_EMAIL';\n\t\tif (verifyEmail) {\n\t\t\tawait this.enforceAuth();\n\t\t\temail = this.user.email;\n\t\t}\n\n\t\treturn void this.api('sendOobCode', {\n\t\t\tidToken: verifyEmail ? this.user.tokenManager.idToken : undefined,\n\t\t\trequestType,\n\t\t\temail,\n\t\t\tcontinueUrl: this.redirectUri + `?email=${email}`\n\t\t});\n\t}\n\n\t/**\n\t * Sets a new password by using a reset code.\n\t * Can also be used to very oobCode by not passing a password.\n\t * @param {string} code\n\t * @returns {string} The email of the account to which the code was issued.\n\t */\n\tasync resetPassword(oobCode, newPassword) {\n\t\treturn (await this.api('resetPassword', { oobCode, newPassword })).email;\n\t}\n\n\t/**\n\t * Returns info about all providers associated with a specified email.\n\t * @param {string} email The user's email address.\n\t * @returns {ProvidersForEmailResponse}\n\t */\n\tasync fetchProvidersForEmail(email) {\n\t\tconst response = await this.api('createAuthUri', { identifier: email, continueUri: location.href });\n\t\tdelete response.kind;\n\t\treturn response;\n\t}\n\n\t/**\n\t * Gets the user data from the server, and updates the local caches.\n\t * @param {Object} [tokenManager] Only when not logged in.\n\t * @throws Will throw if the user is not signed in.\n\t */\n\tasync fetchProfile(tokenManager = this.user && this.user.tokenManager) {\n\t\tif (!tokenManager) await this.enforceAuth();\n\n\t\tconst userData = (await this.api('lookup', { idToken: tokenManager.idToken })).users[0];\n\n\t\tdelete userData.kind;\n\t\tuserData.tokenManager = tokenManager;\n\n\t\tawait this.setState(userData);\n\t}\n\n\t/**\n\t * Update user's profile.\n\t * @param {Object} newData An object with the new data to overwrite.\n\t * @throws Will throw if the user is not signed in.\n\t */\n\tasync updateProfile(newData) {\n\t\tawait this.enforceAuth();\n\n\t\t// Calculate the expiration date for the idToken.\n\t\tconst updatedData = await this.api('update', {\n\t\t\t...newData,\n\t\t\tidToken: this.user.tokenManager.idToken,\n\t\t\treturnSecureToken: true\n\t\t});\n\n\t\tconst { idToken, refreshToken, expiresAt } = updatedData;\n\n\t\tif (updatedData.idToken) {\n\t\t\tupdatedData.tokenManager = { idToken, refreshToken, expiresAt };\n\t\t} else {\n\t\t\tupdatedData.tokenManager = this.user.tokenManager;\n\t\t}\n\n\t\tdelete updatedData.kind;\n\t\tdelete updatedData.idToken;\n\t\tdelete updatedData.refreshToken;\n\n\t\tawait this.setState(updatedData);\n\t}\n\n\t/**\n\t * Deletes the currently logged in account and logs out.\n\t * @throws Will throw if the user is not signed in.\n\t */\n\tasync deleteAccount() {\n\t\tawait this.enforceAuth();\n\t\tawait this.api('delete', `{\"idToken\": \"${this.user.tokenManager.idToken}\"}`);\n\t\tthis.signOut();\n\t}\n}\n"]}